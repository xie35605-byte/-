<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ä½™è‹±æ¥  - åƒé‡Œæ±Ÿå±± (æµä½“å…¸è—ç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000508; font-family: 'Songti SC', serif; user-select: none; }
        
        /* ç•Œé¢UI */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; pointer-events: auto; z-index: 20;
            color: rgba(74, 166, 225, 0.9);
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
            transition: opacity 0.5s;
        }
        .title {
            font-size: 24px; font-weight: bold; letter-spacing: 4px;
            text-shadow: 0 0 10px rgba(0, 255, 200, 0.3);
            border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; margin-bottom: 10px;
        }
        .instruction { font-size: 14px; color: #ffd700; margin-top: 8px; font-weight: bold; animation: pulse 2s infinite;}

        /* æŒ‰é’®ç»„ */
        .btn-group { margin-top: 15px; display: flex; gap: 10px; }
        .ui-btn {
            border: 1px solid rgba(74, 166, 225, 0.5);
            background: rgba(0, 20, 30, 0.6);
            color: #4aa6e1;
            padding: 5px 12px;
            font-size: 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s;
            backdrop-filter: blur(4px);
        }
        .ui-btn:hover { background: rgba(74, 166, 225, 0.2); color: white; }

        /* æ‘„åƒå¤´å°çª— */
        #cam-wrapper {
            position: absolute; bottom: 20px; left: 20px;
            width: 160px; height: 120px; z-index: 10;
            border-radius: 8px; overflow: hidden;
            border: 1px solid rgba(157, 122, 86, 0.5);
            background: #000;
            display: none; opacity: 0.8; transition: opacity 0.3s;
        }
        #cam-wrapper:hover { opacity: 1; }
        #raw-video, #cam-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #cam-canvas { z-index: 2; }

        /* åŠ è½½é®ç½© */
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000508; display: flex; justify-content: center; align-items: center;
            flex-direction: column; z-index: 100; transition: opacity 0.8s; pointer-events: none;
        }
        .loader-ring {
            width: 50px; height: 50px; border: 2px solid #1a587d; 
            border-top: 2px solid #ffd700; border-radius: 50%; 
            animation: spin 1s linear infinite;
        }
        .loader-text { color: #238e68; font-size: 16px; margin-top: 15px; letter-spacing: 3px; }
        @keyframes spin {0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}
        @keyframes pulse {0%{opacity:0.6;}50%{opacity:1;}100%{opacity:0.6;}}
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        <div class="loader-ring"></div>
        <div class="loader-text">æ­£åœ¨é“ºé™ˆåƒé‡Œæ±Ÿå±±...</div>
    </div>

    <div id="ui-layer">
        <div class="title">åƒé‡Œæ±Ÿå±± Â· ç”Ÿè¾°ç¤¼</div>
        <div class="instruction" id="instruction-text">ç­‰å¾…æŒ‡ä»¤...</div>
        
        <div class="btn-group">
            <button class="ui-btn" onclick="toggleFullScreen()">â›¶ å…¨å±æ²‰æµ¸</button>
            <button class="ui-btn" onclick="toggleUI()">ğŸ‘ æ˜¾ç¤º/éšè—</button>
        </div>
    </div>

    <div id="cam-wrapper">
        <video id="raw-video" autoplay muted playsinline></video>
        <canvas id="cam-canvas"></canvas>
    </div>

<script>
// --- UI åŠŸèƒ½ ---
function toggleFullScreen() {
    if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(e=>{});
    else if (document.exitFullscreen) document.exitFullscreen();
}
let isUIHidden = false;
function toggleUI() {
    const ui = document.getElementById('ui-layer');
    isUIHidden = !isUIHidden;
    ui.style.opacity = isUIHidden ? 0.05 : 1;
}

// --- é…ç½® ---
const CONFIG = {
    particleCount: 65000, 
    texts: ["5", "4", "3", "2", "1", "ä½™è‹±æ¥ ", "ç”Ÿæ—¥å¿«ä¹", "â¤"],
    colors: {
        gold: new THREE.Color('#ffd700'),
        cyan: new THREE.Color('#20b2aa'),
        dark: new THREE.Color('#004433')
    }
};

let scene, camera, renderer, material, geometry;
let textPointsCache = [];
let currentStep = 0;
// åŒæ¨¡æ§åˆ¶çŠ¶æ€
let isHandFist = false;
let isMouseDown = false;
let time = 0;
let mixVal = 0;
let scaleVal = 0;

window.onload = function() {
    initThree();
    setTimeout(() => {
        document.getElementById('loading').style.opacity = 0;
        setTimeout(() => document.getElementById('loading').style.display = 'none', 800);
        attemptCameraStart();
    }, 1500);
};

function initThree() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000508, 0.002);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    // æ™ºèƒ½é€‚é…å±å¹•å®½åº¦
    if(window.innerWidth > window.innerHeight) camera.position.z = 120; // ç”µè„‘/å¹³æ¿
    else camera.position.z = 220; // æ‰‹æœº

    renderer = new THREE.WebGLRenderer({ powerPreference: "high-performance", alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    preloadTextData();
    createFluidParticles();
    setTargetText(0);
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // é¼ æ ‡/è§¦æ‘¸äº‹ä»¶ (åŒæ¨¡æ§åˆ¶)
    const handleStart = () => { isMouseDown = true; };
    const handleEnd = () => { if(isMouseDown) triggerNextStep(); isMouseDown = false; };

    document.addEventListener('mousedown', handleStart);
    document.addEventListener('mouseup', handleEnd);
    document.addEventListener('touchstart', (e) => { handleStart(); }, {passive: false});
    document.addEventListener('touchend', handleEnd);
}

function triggerNextStep() {
    if (mixVal > 0.3) {
        currentStep = (currentStep + 1) % CONFIG.texts.length;
        setTargetText(currentStep);
    }
}

function createFluidParticles() {
    geometry = new THREE.BufferGeometry();
    const count = CONFIG.particleCount;
    const positions = new Float32Array(count * 3);
    const targetPos = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);
    const sizes = new Float32Array(count);
    const randoms = new Float32Array(count * 3);

    for(let i=0; i<count; i++) {
        const r = Math.random() * 60 + 10;
        const theta = Math.random() * Math.PI * 2;
        const y = (Math.random() - 0.5) * 100;
        
        positions[i*3] = r * Math.cos(theta);
        positions[i*3+1] = y;
        positions[i*3+2] = r * Math.sin(theta);

        targetPos[i*3] = positions[i*3];
        targetPos[i*3+1] = positions[i*3+1];
        targetPos[i*3+2] = positions[i*3+2];

        randoms[i*3] = Math.random();
        randoms[i*3+1] = Math.random();
        randoms[i*3+2] = Math.random();

        let c = Math.random() > 0.8 ? CONFIG.colors.gold : (Math.random()>0.5 ? CONFIG.colors.cyan : CONFIG.colors.dark);
        colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
        sizes[i] = Math.random();
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('target', new THREE.BufferAttribute(targetPos, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
    geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));

    const vertexShader = `
        uniform float uTime;
        uniform float uMix; 
        uniform float uScale;
        attribute vec3 target;
        attribute float aSize;
        attribute vec3 color;
        attribute vec3 aRandom;
        varying vec3 vColor;

        void main() {
            vColor = color;
            vec3 pos = position;

            // è‡ªç”±æ€æµä½“
            float angle = uTime * 0.2 * (aRandom.x + 0.5);
            float s = sin(angle); float c = cos(angle);
            vec3 fluidPos = pos;
            fluidPos.xy = mat2(c, -s, s, c) * fluidPos.xy;
            fluidPos += normal * (sin(uTime + pos.y*0.1) * 5.0); // ç®€å•çš„æ³¢åŠ¨

            // èšåˆæ€ï¼šé£å‘æ–‡å­—
            vec3 textPos = target + vec3(sin(uTime*10.0+pos.x)*0.5); // å¾®å¾®éœ‡åŠ¨

            vec3 finalPos = mix(fluidPos, textPos, uMix);

            vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            
            float size = (3.0 * aSize + 1.0) * (1.0 + uMix * 0.5) * (200.0 / -mvPosition.z);
            gl_PointSize = size;
        }
    `;

    const fragmentShader = `
        varying vec3 vColor;
        void main() {
            vec2 uv = gl_PointCoord.xy - 0.5;
            float r = length(uv);
            if(r > 0.5) discard;
            float glow = 1.0 - smoothstep(0.3, 0.5, r);
            gl_FragColor = vec4(vColor, glow * 0.8);
        }
    `;

    material = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 }, uMix: { value: 0 }, uScale: { value: 0 } },
        vertexShader, fragmentShader,
        transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
    });

    scene.add(new THREE.Points(geometry, material));
}

function preloadTextData() {
    const cvs = document.createElement('canvas');
    cvs.width = 256; cvs.height = 256;
    const ctx = cvs.getContext('2d');
    CONFIG.texts.forEach(txt => {
        ctx.clearRect(0,0,256,256);
        ctx.fillStyle = 'white'; 
        ctx.font = txt.length > 2 ? 'bold 50px "Songti SC"' : 'bold 150px "Songti SC"';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(txt, 128, 128);
        const data = ctx.getImageData(0,0,256,256).data;
        const pts = [];
        for(let y=0; y<256; y+=2) {
            for(let x=0; x<256; x+=2) {
                if(data[(y*256+x)*4] > 128) {
                    pts.push({ x: (x - 128) * 1.5, y: -(y - 128) * 1.5 });
                }
            }
        }
        textPointsCache.push(pts);
    });
}

function setTargetText(idx) {
    const pts = textPointsCache[idx];
    if(!pts || !geometry) return;
    const attr = geometry.attributes.target;
    const arr = attr.array;
    const count = CONFIG.particleCount;
    for(let i=0; i<count; i++) {
        const i3 = i*3;
        if(i < pts.length * 15) { 
            const p = pts[i % pts.length];
            arr[i3] = p.x + (Math.random()-0.5)*2;
            arr[i3+1] = p.y + (Math.random()-0.5)*2;
            arr[i3+2] = (Math.random()-0.5)*5;
        } else {
            const ang = i * 0.02;
            const r = 100 + Math.random() * 80;
            arr[i3] = Math.cos(ang) * r;
            arr[i3+1] = Math.sin(ang) * r;
            arr[i3+2] = (Math.random()-0.5) * 100;
        }
    }
    attr.needsUpdate = true;
}

function animate() {
    requestAnimationFrame(animate);
    time += 0.01;

    // æ ¸å¿ƒåŒæ§é€»è¾‘ï¼šæ¡æ‹³ OR æŒ‰ä½é¼ æ ‡ éƒ½ä¼šè§¦å‘
    const isInteracting = isHandFist || isMouseDown;

    const targetMix = isInteracting ? 1.0 : 0.0;
    const targetScale = isInteracting ? 0.0 : 0.5;
    
    mixVal += (targetMix - mixVal) * 0.05;
    scaleVal += (targetScale - scaleVal) * 0.05;

    material.uniforms.uTime.value = time;
    material.uniforms.uMix.value = mixVal;
    material.uniforms.uScale.value = scaleVal;

    renderer.render(scene, camera);
}

async function attemptCameraStart() {
    const statusEl = document.getElementById('status-text');
    const instructEl = document.getElementById('instruction-text');
    
    // æ£€æŸ¥å®‰å…¨ç¯å¢ƒ
    if (window.location.protocol === 'file:') {
        instructEl.innerHTML = "ğŸ–±ï¸ è§¦æ§æ¨¡å¼ï¼šé•¿æŒ‰å±å¹•èšåˆ";
        return;
    }

    try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240, facingMode: 'user' } });
        const video = document.getElementById('raw-video');
        video.srcObject = stream;
        await video.play();
        document.getElementById('cam-wrapper').style.display = 'block';

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onHandsResult);
        
        const cam = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 320, height: 240 });
        cam.start();

        statusEl.innerText = "ğŸŸ¢ äº¤äº’å°±ç»ª";
        instructEl.innerHTML = "âœŠ æ¡æ‹³ / ğŸ–±ï¸ é•¿æŒ‰ å‡å¯æ§åˆ¶";

    } catch (err) {
        statusEl.innerHTML = "æ‘„åƒå¤´æœªå¯ç”¨";
        instructEl.innerHTML = "ğŸ–±ï¸ è§¦æ§æ¨¡å¼ï¼šé•¿æŒ‰å±å¹•èšåˆ";
    }
}

function onHandsResult(results) {
    const canvas = document.getElementById('cam-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color: '#00ff00', lineWidth: 2});
        drawLandmarks(ctx, landmarks, {color: '#ff0000', lineWidth: 1});

        const wrist = landmarks[0];
        const tips = [8, 12, 16, 20];
        let curled = 0;
        tips.forEach(t => {
            const tip = landmarks[t];
            const base = landmarks[t-2]; 
            if (Math.hypot(tip.x - wrist.x, tip.y - wrist.y) < Math.hypot(base.x - wrist.x, base.y - wrist.y)) curled++;
        });

        const isFistNow = curled >= 3;
        
        // å½“æ‰‹åŠ¿æ¾å¼€æ—¶ï¼Œåˆ‡å­—ï¼ˆåŒæ—¶è¦ç¡®ä¿é¼ æ ‡ä¹Ÿæ²¡æŒ‰ç€ï¼‰
        if (isHandFist && !isFistNow && !isMouseDown) {
            triggerNextStep();
        }
        isHandFist = isFistNow;
    } else {
        isHandFist = false;
    }
}
</script>
</body>
</html>