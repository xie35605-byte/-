<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ä½™è‹±æ¥  - åƒé‡Œæ±Ÿå±± (å…¸è—åŸè‰²ç‰ˆ)</title>
    <style>
        /* èƒŒæ™¯å›å½’åŸæœ¬çš„æ·±é’é»‘è‰²ï¼Œæ— æ˜Ÿæ˜Ÿå¹²æ‰° */
        body { margin: 0; overflow: hidden; background-color: #000508; font-family: 'Songti SC', serif; user-select: none; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; pointer-events: auto; z-index: 20;
            color: rgba(74, 166, 225, 0.9); /* åŸç‰ˆé’è‰²å­—ä½“ */
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
            transition: opacity 0.5s;
        }
        /* æ ‡é¢˜æ”¹å›åŸç‰ˆ */
        .title {
            font-size: 24px; font-weight: bold; letter-spacing: 4px;
            text-shadow: 0 0 10px rgba(0, 255, 200, 0.3);
            border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; margin-bottom: 10px;
        }
        .instruction { font-size: 14px; color: #ffd700; margin-top: 8px; font-weight: bold; animation: pulse 2s infinite; }
        
        .btn-group { margin-top: 15px; display: flex; gap: 10px; }
        .ui-btn {
            border: 1px solid rgba(74, 166, 225, 0.5);
            background: rgba(0, 20, 30, 0.6);
            color: #4aa6e1;
            padding: 5px 12px;
            font-size: 12px;
            cursor: pointer;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
            backdrop-filter: blur(4px);
        }

        #cam-wrapper {
            position: absolute; bottom: 20px; left: 20px;
            width: 160px; height: 120px; z-index: 10;
            border-radius: 8px; overflow: hidden;
            border: 1px solid rgba(157, 122, 86, 0.5); /* èµ­çŸ³è‰²è¾¹æ¡†å›å½’ */
            background: #000;
            display: none; opacity: 0.8; transition: opacity 0.3s;
        }
        #cam-wrapper:hover { opacity: 1; }
        #raw-video, #cam-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #cam-canvas { z-index: 2; }

        /* åŸç‰ˆåŠ è½½åŠ¨ç”»é£æ ¼ */
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000508; display: flex; justify-content: center; align-items: center;
            flex-direction: column; z-index: 100; transition: opacity 0.8s; pointer-events: none;
        }
        .loader-ring {
            width: 50px; height: 50px; border: 2px solid #1a587d; 
            border-top: 2px solid #ffd700; border-radius: 50%; 
            animation: spin 1s linear infinite;
        }
        .loader-text { color: #238e68; font-size: 16px; margin-top: 15px; letter-spacing: 3px; }
        @keyframes spin {0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}
        @keyframes pulse {0%{opacity:0.6;}50%{opacity:1;}100%{opacity:0.6;}}
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        <div class="loader-ring"></div>
        <div class="loader-text">æ­£åœ¨ç ”ç£¨é’ç»¿é¢œæ–™...</div>
    </div>

    <div id="ui-layer">
        <div class="title">åƒé‡Œæ±Ÿå±± Â· ç”Ÿè¾°ç¤¼</div> <!-- æ ‡é¢˜å·²é”å®š -->
        <div class="instruction" id="instruction-text">ç­‰å¾…æŒ‡ä»¤...</div>
        <div class="btn-group">
            <button class="ui-btn" onclick="toggleFullScreen()">â›¶ æ²‰æµ¸å…¨å±</button>
            <button class="ui-btn" onclick="toggleUI()">ğŸ‘ æ˜¾ç¤º/éšè—</button>
        </div>
    </div>

    <div id="cam-wrapper">
        <video id="raw-video" autoplay muted playsinline></video>
        <canvas id="cam-canvas"></canvas>
    </div>

<script>
function toggleFullScreen() {
    if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(e=>{});
    else if (document.exitFullscreen) document.exitFullscreen();
}
let isUIHidden = false;
function toggleUI() {
    const ui = document.getElementById('ui-layer');
    isUIHidden = !isUIHidden;
    ui.style.opacity = isUIHidden ? 0.05 : 1;
}

// --- ç»å…¸ç‰ˆé…è‰²é…ç½® ---
const CONFIG = {
    particleCount: 65000, // é«˜ç”»è´¨
    texts: ["5", "4", "3", "2", "1", "ä½™è‹±æ¥ ", "ç”Ÿæ—¥å¿«ä¹", "â¤"],
    colors: {
        bg: 0x000508,
        cyanDark: new THREE.Color('#104b3a'), // çŸ³ç»¿
        cyanLight: new THREE.Color('#4aa6e1'), // çŸ³é’
        gold: new THREE.Color('#ffd700')       // æ³¥é‡‘
    }
};

let scene, camera, renderer, material, geometry;
let textPointsCache = [];
let currentStep = 0;
let isHandFist = false;
let isMouseDown = false;
let time = 0;
let mixVal = 0;
let scaleVal = 0;

window.onload = function() {
    initThree();
    setTimeout(() => {
        document.getElementById('loading').style.opacity = 0;
        setTimeout(() => document.getElementById('loading').style.display = 'none', 800);
        attemptCameraStart();
    }, 1500);
};

function initThree() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.002); // ç»å…¸è¿·é›¾

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    updateCameraPosition(); // æ™ºèƒ½é€‚é…

    renderer = new THREE.WebGLRenderer({ powerPreference: "high-performance", alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    preloadTextData();
    createFluidParticles(); // æ— æ˜Ÿæ˜ŸèƒŒæ™¯
    setTargetText(0);
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        updateCameraPosition();
    });

    const handleStart = () => { isMouseDown = true; };
    const handleEnd = () => { if(isMouseDown) triggerNextStep(); isMouseDown = false; };
    document.addEventListener('mousedown', handleStart);
    document.addEventListener('mouseup', handleEnd);
    document.addEventListener('touchstart', (e) => { handleStart(); }, {passive: false});
    document.addEventListener('touchend', handleEnd);
}

function updateCameraPosition() {
    const aspect = window.innerWidth / window.innerHeight;
    // ç»å…¸ç‰ˆç›¸æœºå‚æ•°
    if (aspect > 1) camera.position.z = 130; 
    else camera.position.z = 240; 
}

function triggerNextStep() {
    if (mixVal > 0.3) {
        currentStep = (currentStep + 1) % CONFIG.texts.length;
        setTargetText(currentStep);
    }
}

function createFluidParticles() {
    geometry = new THREE.BufferGeometry();
    const count = CONFIG.particleCount;
    const positions = new Float32Array(count * 3);
    const targetPos = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);
    const sizes = new Float32Array(count);
    const randoms = new Float32Array(count * 3);

    for(let i=0; i<count; i++) {
        const r = Math.random() * 80 + 20;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        
        positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i*3+2] = r * Math.cos(phi);

        targetPos[i*3] = positions[i*3];
        targetPos[i*3+1] = positions[i*3+1];
        targetPos[i*3+2] = positions[i*3+2];

        randoms[i*3] = Math.random();
        randoms[i*3+1] = Math.random();
        randoms[i*3+2] = Math.random();

        // ç»å…¸é…è‰²é€»è¾‘
        let c;
        const rnd = Math.random();
        if (rnd > 0.9) c = CONFIG.colors.gold; // 10% é‡‘
        else if (rnd > 0.6) c = CONFIG.colors.cyanLight; // 30% çŸ³é’
        else c = CONFIG.colors.cyanDark; // 60% çŸ³ç»¿

        colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
        sizes[i] = Math.random();
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('target', new THREE.BufferAttribute(targetPos, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
    geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));

    const vertexShader = `
        uniform float uTime;
        uniform float uMix; 
        uniform float uScale;
        attribute vec3 target;
        attribute float aSize;
        attribute vec3 color;
        attribute vec3 aRandom;
        varying vec3 vColor;

        void main() {
            vColor = color;
            vec3 pos = position;

            // ç»å…¸æµä½“è¿åŠ¨ - æ›´åŠ å¹³æ»‘æŸ”é¡º
            float angle = uTime * 0.1 * aSize;
            float s = sin(angle); float c = cos(angle);
            pos.xy = mat2(c, -s, s, c) * pos.xy;
            
            // æ¨¡æ‹Ÿæ°´å¢¨æ™•æŸ“çš„æ³¢åŠ¨
            vec3 noiseOffset = vec3(
                sin(pos.y * 0.05 + uTime * 0.5),
                cos(pos.x * 0.05 + uTime * 0.5),
                sin(pos.z * 0.05 + uTime * 0.5)
            ) * (10.0 + uScale * 20.0);
            pos += noiseOffset;

            // èšåˆé€»è¾‘
            vec3 finalPos = mix(pos, target, uMix);

            vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            
            // ç²’å­å¤§å° - ç¨å¾®å°ä¸€ç‚¹ç‚¹ï¼Œä¸ºäº†æ°´å¢¨çš„ç»†è…»æ„Ÿ
            float size = (3.0 * aSize + 1.0) * (1.0 + uMix * 0.5) * (200.0 / -mvPosition.z);
            gl_PointSize = size;
        }
    `;

    const fragmentShader = `
        varying vec3 vColor;
        void main() {
            vec2 uv = gl_PointCoord.xy - 0.5;
            float r2 = dot(uv, uv);
            if(r2 > 0.25) discard;
            float alpha = 1.0 - smoothstep(0.1, 0.25, r2);
            gl_FragColor = vec4(vColor * 1.5, alpha * 0.8);
        }
    `;

    material = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 }, uMix: { value: 0 }, uScale: { value: 0 } },
        vertexShader, fragmentShader,
        transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
    });

    scene.add(new THREE.Points(geometry, material));
}

function preloadTextData() {
    const cvs = document.createElement('canvas');
    cvs.width = 128; cvs.height = 128;
    const ctx = cvs.getContext('2d');
    CONFIG.texts.forEach(txt => {
        ctx.clearRect(0,0,128,128);
        ctx.fillStyle = 'white'; 
        ctx.font = txt.length > 2 ? 'bold 24px "Songti SC"' : 'bold 70px "Songti SC"';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(txt, 64, 64);
        const data = ctx.getImageData(0,0,128,128).data;
        const pts = [];
        for(let y=0; y<128; y++) {
            for(let x=0; x<128; x++) {
                if(data[(y*128+x)*4] > 120) {
                    pts.push({ x: (x - 64) * 3.5, y: -(y - 64) * 3.5 });
                }
            }
        }
        textPointsCache.push(pts);
    });
}

function setTargetText(idx) {
    const pts = textPointsCache[idx];
    if(!pts || !geometry) return;
    const attr = geometry.attributes.target;
    const arr = attr.array;
    const count = CONFIG.particleCount;
    for(let i=0; i<count; i++) {
        const i3 = i*3;
        if(i < pts.length * 15 && i < count) { 
            const p = pts[i % pts.length];
            arr[i3] = p.x + (Math.random()-0.5)*2;
            arr[i3+1] = p.y + (Math.random()-0.5)*2;
            arr[i3+2] = (Math.random()-0.5)*5;
        } else {
            const ang = i * 0.01;
            const r = 100 + Math.random() * 80;
            arr[i3] = Math.cos(ang) * r;
            arr[i3+1] = Math.sin(ang) * r;
            arr[i3+2] = (Math.random()-0.5) * 80;
        }
    }
    attr.needsUpdate = true;
}

function animate() {
    requestAnimationFrame(animate);
    time += 0.01;
    const isInteracting = isHandFist || isMouseDown;
    const targetMix = isInteracting ? 1.0 : 0.0;
    const targetScale = isInteracting ? 0.0 : 0.5; 
    mixVal += (targetMix - mixVal) * 0.08;
    scaleVal += (targetScale - scaleVal) * 0.08;
    material.uniforms.uTime.value = time;
    material.uniforms.uMix.value = mixVal;
    material.uniforms.uScale.value = scaleVal;
    renderer.render(scene, camera);
}

async function attemptCameraStart() {
    if (window.location.protocol === 'file:') {
        document.getElementById('instruction-text').innerHTML = "ğŸ–±ï¸ æŒ‰ä½é¼ æ ‡ / é•¿æŒ‰å±å¹• èšåˆ";
        return; 
    }
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240, facingMode: 'user' } });
        const video = document.getElementById('raw-video');
        video.srcObject = stream;
        await video.play();
        document.getElementById('cam-wrapper').style.display = 'block'; 
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onHandsResult);
        const cam = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 320, height: 240 });
        cam.start();
        document.getElementById('instruction-text').innerHTML = "âœŠ æ¡æ‹³(æˆ–æŒ‰é¼ æ ‡) èšåˆ | ğŸ– æ¾å¼€æ•£å¼€";
    } catch (err) {
        document.getElementById('instruction-text').innerHTML = "ğŸ–±ï¸ æŒ‰ä½é¼ æ ‡ / é•¿æŒ‰å±å¹• èšåˆ";
    }
}

function onHandsResult(results) {
    const canvas = document.getElementById('cam-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color: '#104b3a', lineWidth: 2}); // ç»¿è‰²éª¨éª¼
        drawLandmarks(ctx, landmarks, {color: '#ffd700', lineWidth: 1});
        const wrist = landmarks[0];
        const tips = [8, 12, 16, 20];
        let curled = 0;
        tips.forEach(t => {
            const tip = landmarks[t];
            const base = landmarks[t-2];
            if(Math.hypot(tip.x-wrist.x, tip.y-wrist.y) < Math.hypot(base.x-wrist.x, base.y-wrist.y)) curled++;
        });
        const isFistNow = curled >= 3;
        if (isHandFist && !isFistNow && !isMouseDown) triggerNextStep();
        isHandFist = isFistNow;
    } else {
        isHandFist = false;
    }
}
</script>
</body>
</html>