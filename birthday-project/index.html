<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ä½™è‹±æ¥  - æ˜Ÿé™…ç‰ˆ (æ ‡é¢˜ä¿®å¤)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000205; font-family: 'Songti SC', serif; user-select: none; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; pointer-events: auto; z-index: 20;
            color: rgba(180, 220, 255, 0.8);
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
            transition: opacity 0.5s;
        }
        /* æ ‡é¢˜æ”¹å›äº†â€œåƒé‡Œæ±Ÿå±± Â· ç”Ÿè¾°ç¤¼â€ */
        .title {
            font-size: 22px; font-weight: bold; letter-spacing: 4px;
            background: linear-gradient(to right, #4aa6e1, #ffd700);
            -webkit-background-clip: text; color: transparent;
            margin-bottom: 5px;
        }
        .instruction { font-size: 13px; color: #ffd700; margin-top: 5px; font-weight: bold; animation: pulse 2s infinite; }
        
        .btn-group { margin-top: 10px; display: flex; gap: 8px; }
        .ui-btn {
            border: 1px solid rgba(74, 166, 225, 0.3);
            background: rgba(0, 10, 20, 0.5);
            color: #4aa6e1;
            padding: 5px 10px;
            font-size: 11px;
            cursor: pointer;
            border-radius: 4px;
            backdrop-filter: blur(4px);
        }
        
        #cam-wrapper {
            position: absolute; bottom: 20px; left: 20px;
            width: 120px; height: 90px; z-index: 10;
            border-radius: 6px; overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: #000;
            display: none; opacity: 0.6; transition: opacity 0.3s;
        }
        #cam-wrapper:hover { opacity: 1; }
        #raw-video, #cam-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #cam-canvas { z-index: 2; }

        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000205; display: flex; justify-content: center; align-items: center;
            flex-direction: column; z-index: 100; transition: opacity 1s; pointer-events: none;
        }
        .star-loader {
            width: 4px; height: 4px; background: #fff; border-radius: 50%;
            box-shadow: 0 0 30px 10px #4aa6e1;
            animation: pulse 0.8s infinite alternate;
        }
        .loader-text { color: #4aa6e1; font-size: 14px; margin-top: 20px; letter-spacing: 4px; opacity: 0.8; }
        @keyframes pulse {0%{transform:scale(1); opacity:0.5;}100%{transform:scale(1.5); opacity:1;}}
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        <div class="star-loader"></div>
        <div class="loader-text">æ˜Ÿè½¨æ ¡å‡†ä¸­...</div>
    </div>

    <div id="ui-layer">
        <div class="title">åƒé‡Œæ±Ÿå±± Â· ç”Ÿè¾°ç¤¼</div> <!-- æ ‡é¢˜å·²ä¿®å¤ -->
        <div class="instruction" id="instruction-text">ç­‰å¾…æŒ‡ä»¤...</div>
        <div class="btn-group">
            <button class="ui-btn" onclick="toggleFullScreen()">â›¶ å…¨å±</button>
            <button class="ui-btn" onclick="toggleUI()">ğŸ‘ ç•Œé¢</button>
        </div>
    </div>

    <div id="cam-wrapper">
        <video id="raw-video" autoplay muted playsinline></video>
        <canvas id="cam-canvas"></canvas>
    </div>

<script>
function toggleFullScreen() {
    if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(e=>{});
    else if (document.exitFullscreen) document.exitFullscreen();
}
let isUIHidden = false;
function toggleUI() {
    const ui = document.getElementById('ui-layer');
    isUIHidden = !isUIHidden;
    ui.style.opacity = isUIHidden ? 0.05 : 1;
}

const CONFIG = {
    particleCount: 65000, 
    starCount: 3000,      
    texts: ["5", "4", "3", "2", "1", "ä½™è‹±æ¥ ", "ç”Ÿæ—¥å¿«ä¹", "â¤"],
    colors: {
        gold: new THREE.Color('#ffdd55'),
        cyan: new THREE.Color('#20b2aa'), 
        deep: new THREE.Color('#001133')
    }
};

let scene, camera, renderer, material, geometry, stars;
let textPointsCache = [];
let currentStep = 0;
let isHandFist = false;
let isMouseDown = false;
let time = 0;
let mixVal = 0;
let scaleVal = 0;

window.onload = function() {
    initThree();
    setTimeout(() => {
        document.getElementById('loading').style.opacity = 0;
        setTimeout(() => document.getElementById('loading').style.display = 'none', 1000);
        attemptCameraStart();
    }, 1200);
};

function initThree() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000205, 0.001);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    updateCameraPosition();

    renderer = new THREE.WebGLRenderer({ powerPreference: "high-performance", alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    preloadTextData();
    createStarField();
    createFluidParticles();
    setTargetText(0);
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        updateCameraPosition(); 
    });

    const handleStart = () => { isMouseDown = true; };
    const handleEnd = () => { if(isMouseDown) triggerNextStep(); isMouseDown = false; };
    document.addEventListener('mousedown', handleStart);
    document.addEventListener('mouseup', handleEnd);
    document.addEventListener('touchstart', (e) => { handleStart(); }, {passive: false});
    document.addEventListener('touchend', handleEnd);
}

function updateCameraPosition() {
    const aspect = window.innerWidth / window.innerHeight;
    if (aspect > 1) camera.position.z = 140; 
    else camera.position.z = 240; 
}

function triggerNextStep() {
    if (mixVal > 0.3) {
        currentStep = (currentStep + 1) % CONFIG.texts.length;
        setTargetText(currentStep);
    }
}

function createStarField() {
    const starGeo = new THREE.BufferGeometry();
    const pos = [];
    const sizes = [];
    for(let i=0; i<CONFIG.starCount; i++) {
        pos.push((Math.random()-0.5)*800, (Math.random()-0.5)*800, (Math.random()-0.5)*600 - 100);
        sizes.push(Math.random());
    }
    starGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    starGeo.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));

    const starShaderMat = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 } },
        vertexShader: `
            uniform float uTime;
            attribute float aSize;
            void main() {
                vec4 mv = modelViewMatrix * vec4(position, 1.0);
                gl_Position = projectionMatrix * mv;
                float blink = 0.5 + 0.5 * sin(uTime * 1.5 + position.x * 0.1);
                gl_PointSize = aSize * 3.0 * blink; 
            }
        `,
        fragmentShader: `
            void main() {
                vec2 uv = gl_PointCoord.xy - 0.5;
                if(length(uv) > 0.5) discard;
                gl_FragColor = vec4(0.7, 0.85, 1.0, 0.6);
            }
        `,
        transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
    });
    stars = new THREE.Points(starGeo, starShaderMat);
    scene.add(stars);
}

function createFluidParticles() {
    geometry = new THREE.BufferGeometry();
    const count = CONFIG.particleCount;
    const positions = new Float32Array(count * 3);
    const targetPos = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);
    const sizes = new Float32Array(count);
    const randoms = new Float32Array(count * 3);

    for(let i=0; i<count; i++) {
        const r = Math.random() * 90 + 10;
        const theta = Math.random() * Math.PI * 4;
        
        positions[i*3] = r * Math.cos(theta);
        positions[i*3+1] = (Math.random()-0.5) * 60;
        positions[i*3+2] = r * Math.sin(theta);

        targetPos[i*3] = positions[i*3];
        targetPos[i*3+1] = positions[i*3+1];
        targetPos[i*3+2] = positions[i*3+2];

        randoms[i*3] = Math.random();
        randoms[i*3+1] = Math.random();
        randoms[i*3+2] = Math.random();

        let c;
        const rnd = Math.random();
        if(rnd > 0.75) c = CONFIG.colors.gold; 
        else if(rnd > 0.4) c = CONFIG.colors.cyan; 
        else c = CONFIG.colors.deep; 

        colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
        sizes[i] = Math.random();
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('target', new THREE.BufferAttribute(targetPos, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
    geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));

    const vertexShader = `
        uniform float uTime;
        uniform float uMix; 
        uniform float uScale;
        attribute vec3 target;
        attribute float aSize;
        attribute vec3 color;
        attribute vec3 aRandom;
        varying vec3 vColor;

        void main() {
            vColor = color;
            vec3 pos = position;

            float t = uTime * 0.3;
            pos.x += sin(pos.y * 0.04 + t) * 3.0;
            pos.y += cos(pos.x * 0.04 + t) * 3.0;
            pos.z += sin(pos.x * 0.02 + t) * 5.0;

            float angle = uTime * 0.1 * (aRandom.y - 0.5);
            float s = sin(angle); float c = cos(angle);
            pos.xy = mat2(c, -s, s, c) * pos.xy;
            pos += normal * (15.0 + uScale * 50.0);

            vec3 jitter = vec3(
                sin(uTime * 15.0 + pos.y),
                cos(uTime * 15.0 + pos.x),
                sin(uTime * 15.0 + pos.z)
            ) * 0.15;
            
            vec3 finalPos = mix(pos, target + jitter, uMix);

            vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            
            float size = (4.0 * aSize + 1.0) * (1.0 + uMix * 0.2) * (200.0 / -mvPosition.z);
            gl_PointSize = size;
        }
    `;

    const fragmentShader = `
        varying vec3 vColor;
        void main() {
            vec2 uv = gl_PointCoord.xy - 0.5;
            float r2 = dot(uv, uv);
            if(r2 > 0.25) discard;
            float alpha = 1.0 - smoothstep(0.02, 0.25, r2);
            gl_FragColor = vec4(vColor * 1.8, alpha * 0.9); 
        }
    `;

    material = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0 }, uMix: { value: 0 }, uScale: { value: 0 } },
        vertexShader, fragmentShader,
        transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
    });

    scene.add(new THREE.Points(geometry, material));
}

function preloadTextData() {
    const cvs = document.createElement('canvas');
    cvs.width = 128; cvs.height = 128;
    const ctx = cvs.getContext('2d');
    CONFIG.texts.forEach(txt => {
        ctx.clearRect(0,0,128,128);
        ctx.fillStyle = 'white'; 
        ctx.font = txt.length > 2 ? 'bold 24px "Songti SC"' : 'bold 70px "Songti SC"';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(txt, 64, 64);
        const data = ctx.getImageData(0,0,128,128).data;
        const pts = [];
        for(let y=0; y<128; y++) {
            for(let x=0; x<128; x++) {
                if(data[(y*128+x)*4] > 120) {
                    pts.push({ x: (x - 64) * 3.5, y: -(y - 64) * 3.5 });
                }
            }
        }
        textPointsCache.push(pts);
    });
}

function setTargetText(idx) {
    const pts = textPointsCache[idx];
    if(!pts || !geometry) return;
    const attr = geometry.attributes.target;
    const arr = attr.array;
    const count = CONFIG.particleCount;
    for(let i=0; i<count; i++) {
        const i3 = i*3;
        if(i < pts.length * 20 && i < count) { 
            const p = pts[i % pts.length];
            arr[i3] = p.x + (Math.random()-0.5)*2.0;
            arr[i3+1] = p.y + (Math.random()-0.5)*2.0;
            arr[i3+2] = (Math.random()-0.5)*8.0; 
        } else {
            const ang = i * 0.01;
            const r = 90 + Math.random() * 120;
            arr[i3] = Math.cos(ang) * r;
            arr[i3+1] = Math.sin(ang) * r;
            arr[i3+2] = (Math.random()-0.5) * 150;
        }
    }
    attr.needsUpdate = true;
}

function animate() {
    requestAnimationFrame(animate);
    time += 0.015;
    if(stars) stars.material.uniforms.uTime.value = time;
    const isInteracting = isHandFist || isMouseDown;
    const targetMix = isInteracting ? 1.0 : 0.0;
    const targetScale = isInteracting ? 0.0 : 0.6; 
    mixVal += (targetMix - mixVal) * 0.08;
    scaleVal += (targetScale - scaleVal) * 0.08;
    material.uniforms.uTime.value = time;
    material.uniforms.uMix.value = mixVal;
    material.uniforms.uScale.value = scaleVal;
    renderer.render(scene, camera);
}

async function attemptCameraStart() {
    if (window.location.protocol === 'file:') {
        document.getElementById('instruction-text').innerHTML = "ğŸ–±ï¸ æŒ‰ä½é¼ æ ‡ / é•¿æŒ‰å±å¹• èšåˆ";
        return; 
    }
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240, facingMode: 'user' } });
        const video = document.getElementById('raw-video');
        video.srcObject = stream;
        await video.play();
        document.getElementById('cam-wrapper').style.display = 'block'; 
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onHandsResult);
        const cam = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 320, height: 240 });
        cam.start();
        document.getElementById('instruction-text').innerHTML = "âœŠ æ¡æ‹³(æˆ–æŒ‰é¼ æ ‡) èšåˆ | ğŸ– æ¾å¼€æ•£å¼€";
    } catch (err) {
        document.getElementById('instruction-text').innerHTML = "ğŸ–±ï¸ æŒ‰ä½é¼ æ ‡ / é•¿æŒ‰å±å¹• èšåˆ";
    }
}

function onHandsResult(results) {
    const canvas = document.getElementById('cam-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color: '#4aa6e1', lineWidth: 2});
        drawLandmarks(ctx, landmarks, {color: '#ffd700', lineWidth: 1});
        const wrist = landmarks[0];
        const tips = [8, 12, 16, 20];
        let curled = 0;
        tips.forEach(t => {
            const tip = landmarks[t];
            const base = landmarks[t-2];
            if(Math.hypot(tip.x-wrist.x, tip.y-wrist.y) < Math.hypot(base.x-wrist.x, base.y-wrist.y)) curled++;
        });
        const isFistNow = curled >= 3;
        if (isHandFist && !isFistNow && !isMouseDown) triggerNextStep();
        isHandFist = isFistNow;
    } else {
        isHandFist = false;
    }
}
</script>
</body>
</html>